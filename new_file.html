<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./css/cssSyle-1.css">
    <title>IntersectionObserver</title>
</head>
<body>
    <template id="boxTemplate">
        <div class="sampleBox">
            <div class="label topLeft"></div>
            <div class="label topRight"></div>
            <div class="label bottomLeft"></div>
            <div class="label bottomRight"></div>
        </div>
    </template>
  
    <main>
        <div class="contents">
            <div class="wrapper"></div>
        </div>
    </main>
</body>
<script>

    // 观察者数组,里面存储DOM观察者的对象
    let observers = [];

    // 启动函数
    startup = () => {

        /*
            threshold属性决定了什么时候触发回调函数,即元素进入视口（或者容器元素）多少比例时,执行回调函数。
            它是一个数组,每个成员都是一个门槛值,默认为[0],即交叉比例（intersectionRatio）达到0时触发回调函数。
            如果threshold属性是0.5,当元素进入视口50%时,触发回调函数。
            如果值为[0.3, 0.6],则当元素进入30%和60%时触发回调函数。   
        */
        let thresholdSets = [
            // 第一个box观察之后的触发的时机是由程序动态生成的
            [],
            [0.5],
            [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
            [0, 0.25, 0.5, 0.75, 1.0],
        ];

        // 动态计算第一个盒子的回调函数触发时机,由于遍历范围为0到1,所以每一次任意幅度的向上移动都会触发回调函数
        for (let i = 0; i <= 1.0; i += 0.01) {
            thresholdSets[0].push(i);
        }

        let wrapper = document.querySelector(".wrapper");

        /*
            观察者的配置对象
        */
        let observerOptions = {
            root: null,
            rootMargin: "0px",
            threshold: [],
        };

        // 遍历四个盒子
        for (let i = 0; i < 4; i++) {

            let template = document.querySelector("#boxTemplate").content.cloneNode(true);
            let boxID = "box" + (i + 1);
            template.querySelector(".sampleBox").id = boxID;
            wrapper.appendChild(document.importNode(template, true));

            // 为每一个盒子添加回调函数的触发时机
            observerOptions.threshold = thresholdSets[i];

            // 为生成观察器对象
            observers[i] = new IntersectionObserver(
                intersectionCallback,
                observerOptions
            );
            // 为每个盒子添加观察方法
            observers[i].observe(document.querySelector("#" + boxID));
        }

        // 进入页面后移动到指定的位置
        const position = wrapper.firstElementChild.getBoundingClientRect().top + window.scrollY;
        document.scrollingElement.scrollTop = position;
        document.scrollingElement.scrollLeft = 750;
    };

    // 可见性变化时的回调函数
    intersectionCallback = (entries) => {

        entries.forEach((entry) => {

            // target: 被观察的目标元素,是一个DOM节点对象
            let box = entry.target;
            
            // intersectionRatio: 目标元素的可见比例
            let visiblePct = Math.floor(entry.intersectionRatio * 100) + "%";

            // 将可见比例显示在页面中
            box.querySelector(".topLeft").innerHTML = visiblePct;
            box.querySelector(".topRight").innerHTML = visiblePct;
            box.querySelector(".bottomLeft").innerHTML = visiblePct;
            box.querySelector(".bottomRight").innerHTML = visiblePct;
        });
    };

    startup();
</script>
</html>
